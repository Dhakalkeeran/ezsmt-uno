char *exec_pl=(char *)
/* file automatically generated by fileToC.sh from exec.pl */
"%\n"
"% By Marcello Balduccini [102208]\n"
"%\n"
"% Copyright (C) 2009-2021 Marcello Balduccini. All Rights Reserved.\n"
"%\n"
"\n"
"%:- use_module(library(system)).\n"
"%:- use_module(library(timeout)).\n"
"\n"
"\n"
"batch(sicstus) :-\n"
"	use_module(library(system)),\n"
"	%nofileerrors,\n"
"	set_prolog_flag(fileerrors,off),\n"
"	nodebug,\n"
"	set_prolog_flag(unknown,fail),\n"
"	solve(S),\n"
"%	massage_solution(S,S2),\n"
"	S=S2,\n"
"%	\\+ skip_solution(S2),\n"
"	\\+ solution_exists(S2),\n"
"	output_assignments(S),\n"
"	halt.\n"
"\n"
"\n"
"batch(swiprolog) :-\n"
"	use_module(library(system)),\n"
"	%nofileerrors,\n"
"	set_prolog_flag(fileerrors,off),\n"
"	nodebug,\n"
"	set_prolog_flag(unknown,fail),\n"
"	solve(S),\n"
"%	massage_solution(S,S2),\n"
"	S=S2,\n"
"%	\\+ skip_solution(S2),\n"
"	\\+ solution_exists(S2),\n"
"	output_assignments(S),\n"
"	halt.\n"
"\n"
"\n"
"batch(bprolog) :-\n"
"	%nofileerrors,\n"
"	%set_prolog_flag(fileerrors,off),\n"
"	set_prolog_flag(debug,off),\n"
"	set_prolog_flag(unknown,fail),\n"
"	solve(S),\n"
"%	massage_solution(S,S2),\n"
"	S=S2,\n"
"%	\\+ skip_solution(S2),\n"
"	\\+ solution_exists(S2),\n"
"	output_assignments(S),\n"
"	halt.\n"
"\n"
"%\n"
"% Additional equalities generated by clprq\n"
"% must be turned into (A,B) expressions\n"
"% to have a match with skip_solution/1.\n"
"%\n"
"solution_exists(S) :-\n"
"	skip_solution(E),\n"
"	term_to_string(S,X),\n"
"	term_to_string(E,X).\n"
"\n"
"term_to_string(A,B) :-\n"
"	which_solver(bprolog),\n"
"	term2string(A,B).\n"
"\n"
"term_to_string(A,B) :-\n"
"	which_solver(sicstus3),\n"
"	write_to_chars(A,B).\n"
"\n"
"term_to_string(A,B) :-\n"
"	which_solver(sicstus4),\n"
"	write_to_codes(A,B).\n"
"\n"
"term_to_string(A,B) :-\n"
"	which_solver(swiprolog),\n"
"% write_to_codes/2 is not available in all versions of SWI Prolog\n"
"%	write_to_codes(A,B).\n"
"	format(codes(B), '~w', [A]).\n"
"\n"
"% [marcy 062711] Apparently no longer needed.\n"
"%\n"
"massage_solution([],[]).\n"
"massage_solution([A|ATail],[B|BTail]) :-\n"
"	A =.. [F|Args],\n"
"	F = '=',\n"
"	!,\n"
"	B =.. [','|Args],\n"
"	massage_solution(ATail,BTail).\n"
"massage_solution([A|ATail],[A|BTail]) :-\n"
"	massage_solution(ATail,BTail).\n"
"\n"
"batch(_) :-  % batch must always succeed.\n"
"        write('++failed'),nl,\n"
"        halt. \n"
"\n"
"batch_to(bprolog,Timeout_Millisec) :-\n"
"	time_out(batch(bprolog), Timeout_Millisec, success),\n"
"	halt.\n"
"\n"
"batch_to(sicstus,Timeout_Millisec) :-\n"
"	use_module(library(timeout)),\n"
"	time_out(user:batch(sicstus), Timeout_Millisec, success),\n"
"	halt.\n"
"\n"
"batch_to(swiprolog,Timeout_Millisec) :-\n"
"	use_module(library(timeout)),\n"
"	time_out(user:batch(swiprolog), Timeout_Millisec, success),\n"
"	halt.\n"
"\n"
"batch_to(_,_) :-  % batch must always succeed.\n"
"        write('++failed (TIMEOUT)'),nl,\n"
"        halt.\n"
"\n"
"output_assignments([(ASPName,Var)|Tail]) :-\n"
"	!,\n"
"	write('++'),writeq(ASPName=Var),nl,\n"
"	output_assignments(Tail).\n"
"\n"
"output_assignments([Exp|Tail]) :-\n"
"	write('++'),writeq(Exp),nl,\n"
"	output_assignments(Tail).\n"
"\n"
"output_assignments([]) :-\n"
"	write('++succeeded'), nl.\n"
"\n"
"\n"
"\n"
"/* Wrappers for certain global constraints */\n"
"prepare_disjoint2_list([],[],[],[],[]).\n"
"%\n"
"prepare_disjoint2_list([S1|S1t],[D1|D1t],[S2|S2t],[D2|D2t],[t(S1,D1,S2,D2)|Tail]) :-\n"
"	prepare_disjoint2_list(S1t,D1t,S2t,D2t,Tail).\n"
"%\n"
"disjoint2(L1,L2,L3,L4) :-\n"
"	prepare_disjoint2_list(L1,L2,L3,L4,Rectangles),\n"
"	disjoint2(Rectangles).\n"
"%\n"
"bp_prepare_disjoint2_list([],[],[],[],[]).\n"
"%\n"
"bp_prepare_disjoint2_list([S1|S1t],[D1|D1t],[S2|S2t],[D2|D2t],[[S1,S2,D1,D2]|Tail]) :-\n"
"	bp_prepare_disjoint2_list(S1t,D1t,S2t,D2t,Tail).\n"
"%\n"
"bp_disjoint2(L1,L2,L3,L4) :-\n"
"	bp_prepare_disjoint2_list(L1,L2,L3,L4,Rectangles),\n"
"	diffn(Rectangles).\n"
"\n"
"get_tid(TID) :-\n"
"	curr_tid(TID),\n"
"	!.\n"
"get_tid(0).\n"
"\n"
"set_tid(TID) :-\n"
"	retractall(curr_tid(_)),\n"
"	assert(curr_tid(TID)).\n"
"\n"
"prepare_cumulative_list([],[],[],[]).\n"
"prepare_cumulative_list([S|St],[D|Dt],[R|Rt],[task(S,D,Q,R,TID)|Tail]) :-\n"
"	#=(Q,S+D),\n"
"	prepare_cumulative_list(St,Dt,Rt,Tail),\n"
"	get_tid(TID),\n"
"	TID2 is TID + 1,\n"
"	set_tid(TID2).\n"
"sics4_cumulative(St,Dur,Res,Max) :-\n"
"	prepare_cumulative_list(St,Dur,Res,Tasks),\n"
"	cumulative(Tasks,[limit(Max)]).\n"
"\n"
"bp_cumulative([_],[_],[Res],Max) :-\n"
"	!,\n"
"	Res=<Max.\n"
"bp_cumulative(St,Dur,Res,Max) :-\n"
"	cumulative(St,Dur,Res,Max).\n"
;
